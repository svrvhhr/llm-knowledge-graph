<div class="card">
  <div id="graph-controls" class="controls">
    <div class="controls-left">
      <button onclick="toggleDarkMode()" id="theme-toggle" class="btn btn-outline-dark">Dark Mode</button>
      <button onclick="toggleFilterMenu()" id="filter-toggle" class="btn btn-outline-info">Show Filters</button>
      <button onclick="toggleLabels()" id="labels-toggle" class="btn btn-primary">Hide Labels</button>
      <button onclick="toggleStats()" id="stats-toggle" class="btn btn-outline-secondary">Stats</button>
    </div>

    <div class="controls-right">
      <span class="legend-title"><strong>Edges:</strong></span>
      <span class="legend-line solid"></span><span class="legend-text">Extracted</span>
      <span class="legend-line dashed"></span><span class="legend-text">Inferred</span>
    </div>
  </div>

  <div id="stats-container" class="panel" style="display:none;">
    <h5>Graph Statistics</h5>
    <div class="stats">
      <div><strong>Nodes:</strong> <span id="stat-nodes">-</span></div>
      <div><strong>Edges:</strong> <span id="stat-edges">-</span></div>
      <div><strong>Extracted:</strong> <span id="stat-extracted">-</span></div>
      <div><strong>Inferred:</strong> <span id="stat-inferred">-</span></div>
      <div><strong>Communities:</strong> <span id="stat-communities">-</span></div>
    </div>
  </div>

  <div id="filter-menu-container" class="panel" style="display:none;">
    <div class="filter-row">
      <select id="node-select" class="form-select" onchange="selectNode(this.value)">
        <option value="">Select a Node</option>
      </select>
      <button onclick="resetSelection()" class="btn btn-primary">Reset</button>
    </div>

    <div class="filter-row">
      <select id="item-select" class="form-select">
        <option value="">Select item</option>
        <option value="node">Nodes</option>
        <option value="edge">Edges</option>
      </select>

      <select id="property-select" class="form-select">
        <option value="">Select property</option>
      </select>

      <select id="value-select" class="form-select">
        <option value="">Select value</option>
      </select>

      <button onclick="filterSelection()" class="btn btn-primary">Filter</button>
      <button onclick="resetSelection()" class="btn btn-outline-secondary">Clear</button>
    </div>
  </div>

  <div id="mynetwork" class="card-body"></div>

  <div id="footer"><span>LLM Knowledge Graph</span></div>
</div>

<style id="theme-styles">
  html, body { height:100%; margin:0; padding:0; overflow:hidden; }
  .card { width:100%; height:100vh; display:flex; flex-direction:column; border-radius:0; margin:0; overflow:hidden; }
  .card-body { flex:1; padding:0; overflow:hidden; }

  body.light-mode { background:#fff; color:#111; }
  body.dark-mode  { background:#121212; color:#e0e0e0; }

  .controls {
    margin:10px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    flex-wrap:wrap;
  }
  .controls-left { display:flex; gap:8px; flex-wrap:wrap; }
  .controls-right { display:flex; align-items:center; gap:8px; flex-wrap:wrap; color:#555; }

  .legend-title { margin-right:6px; }
  .legend-line { width:26px; height:2px; display:inline-block; background:#666; }
  .legend-line.dashed { background:transparent; border-top:2px dashed #666; height:0; width:26px; }
  .legend-text { margin-right:10px; }

  .panel {
    margin:10px;
    padding:12px 14px;
    border:1px solid #ddd;
    border-radius:8px;
    background:#f8f9fa;
  }
  body.dark-mode .panel { background:#1e1e1e; border-color:#444; }

  .filter-row { display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; }
  .stats { display:flex; gap:18px; flex-wrap:wrap; }

  body.dark-mode #mynetwork { background:#000; }
  body.dark-mode .form-select { background:#333; color:#e0e0e0; border-color:#555; }

  /* Node label colors */
  .vis-network text { fill:#000 !important; color:#000 !important; }
  body.dark-mode .vis-network text { fill:#fff !important; color:#fff !important; }

  #footer{
    position:absolute;
    bottom:10px;
    left:50%;
    transform:translateX(-50%);
    padding:5px 10px;
    font-size:.85rem;
    background:rgba(255,255,255,.75);
    border-radius:6px;
    color:#6c757d;
    box-shadow:0 1px 3px rgba(0,0,0,.12);
    backdrop-filter:blur(2px);
    z-index:100;
  }
  body.dark-mode #footer{ background:rgba(30,30,30,.75); color:#adb5bd; }
</style>

<script>
  // Initial theme
  document.body.classList.add('light-mode');

  // Track label visibility
  let labelsVisible = true;

  function resizeNetwork() {
    setTimeout(() => { if (window.network) { network.redraw(); network.fit(); } }, 100);
  }

  function updateNodeTextColors(color) {
    if (!window.network?.body?.data?.nodes) return;
    try {
      const nodeIds = network.body.data.nodes.getIds();
      network.body.data.nodes.update(nodeIds.map(id => ({ id, font:{ color, strokeWidth:0 } })));
      setTimeout(() => {
        document.querySelectorAll('.vis-network text').forEach(el => {
          el.style.fill = color; el.setAttribute('fill', color);
        });
      }, 80);
    } catch {}
  }

  function toggleLabels() {
    const btn = document.getElementById('labels-toggle');
    labelsVisible = !labelsVisible;

    if (labelsVisible) {
      network.setOptions({
        nodes:{ font:{ size:14, color: document.body.classList.contains('dark-mode') ? '#fff' : '#000' } },
        edges:{ font:{ size:12, color: document.body.classList.contains('dark-mode') ? '#ffdd00' : '#000' } }
      });
      btn.textContent = 'Hide Labels';
      btn.classList.add('btn-primary');
      btn.classList.remove('btn-outline-primary');
    } else {
      network.setOptions({ nodes:{ font:{ size:0 } }, edges:{ font:{ size:0 } } });
      btn.textContent = 'Show Labels';
      btn.classList.add('btn-outline-primary');
      btn.classList.remove('btn-primary');
    }
  }



  function toggleDarkMode() {
    const body = document.body;
    const btn = document.getElementById('theme-toggle');
    const toDark = !body.classList.contains('dark-mode');

    body.classList.toggle('dark-mode', toDark);
    body.classList.toggle('light-mode', !toDark);
    btn.textContent = toDark ? 'Light Mode' : 'Dark Mode';

    network.setOptions({
      background:{ color: toDark ? '#1e1e1e' : 'white' },
      nodes:{ font:{ color: toDark ? '#fff' : '#000', strokeWidth:0, size: labelsVisible ? 14 : 0 } },
      edges:{ font:{ color: toDark ? '#ffdd00' : '#000', strokeWidth: toDark ? 0 : 4, size: labelsVisible ? 12 : 0 } }
    });

    updateNodeTextColors(toDark ? '#fff' : '#000');
  }

  function toggleFilterMenu() {
    const c = document.getElementById('filter-menu-container');
    const b = document.getElementById('filter-toggle');
    const show = c.style.display === 'none';
    c.style.display = show ? 'block' : 'none';
    b.textContent = show ? 'Hide Filters' : 'Show Filters';
    if (show) populateFilterOptions();
    resizeNetwork();
  }

  function toggleStats() {
    const c = document.getElementById('stats-container');
    const b = document.getElementById('stats-toggle');
    const show = c.style.display === 'none';
    c.style.display = show ? 'block' : 'none';
    b.textContent = show ? 'Hide Stats' : 'Stats';
    if (show) updateGraphStats();
    resizeNetwork();
  }

  function populateFilterOptions() {
    const nodeSelect = document.getElementById('node-select');
    while (nodeSelect.options.length > 1) nodeSelect.remove(1);

    const nodeIds = network.body.data.nodes.getIds();
    nodeIds.forEach(id => {
      const opt = document.createElement('option');
      opt.value = id; opt.text = id;
      nodeSelect.appendChild(opt);
    });

    const itemSelect = document.getElementById('item-select');
    const propertySelect = document.getElementById('property-select');
    const valueSelect = document.getElementById('value-select');

    while (propertySelect.options.length > 1) propertySelect.remove(1);
    while (valueSelect.options.length > 1) valueSelect.remove(1);

    itemSelect.onchange = function() {
      while (propertySelect.options.length > 1) propertySelect.remove(1);
      while (valueSelect.options.length > 1) valueSelect.remove(1);

      if (itemSelect.value === 'node') {
        ['id','label','color','title','community'].forEach(p => {
          const opt = document.createElement('option'); opt.value=p; opt.text=p;
          propertySelect.appendChild(opt);
        });
      } else if (itemSelect.value === 'edge') {
        ['from','to','label','title','inferred'].forEach(p => {
          const opt = document.createElement('option'); opt.value=p; opt.text=p;
          propertySelect.appendChild(opt);
        });
      }
    };

    propertySelect.onchange = function() {
      while (valueSelect.options.length > 1) valueSelect.remove(1);
      const itemType = itemSelect.value;
      const prop = propertySelect.value;
      if (!itemType || !prop) return;

      const values = new Set();
      if (itemType === 'node') {
        network.body.data.nodes.get().forEach(n => {
          if (prop === 'community') {
            const palette = ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf'];
            const idx = palette.indexOf(n.color);
            if (idx >= 0) values.add(String(idx));
          } else if (n[prop] !== undefined) values.add(String(n[prop]));
        });
      } else {
        network.body.data.edges.get().forEach(e => {
          if (prop === 'inferred') values.add(String(e.dashes === true));
          else if (e[prop] !== undefined) values.add(String(e[prop]));
        });
      }

      Array.from(values).sort().forEach(v => {
        const opt = document.createElement('option'); opt.value=v; opt.text=v;
        valueSelect.appendChild(opt);
      });
    };
  }

  function filterSelection() {
    const itemType = document.getElementById('item-select').value;
    const property = document.getElementById('property-select').value;
    const value = document.getElementById('value-select').value;

    if (!itemType || !property || !value) { alert('Select all filter criteria'); return; }

    const nodesToShow = new Set();
    const edgesToShow = new Set();

    try {
      if (itemType === 'node') {
        const palette = ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf'];
        network.body.data.nodes.get().forEach(n => {
          const match = property === 'community'
            ? String(palette.indexOf(n.color)) === value
            : (n[property] !== undefined && String(n[property]) === value);

          if (match) {
            nodesToShow.add(n.id);
            network.getConnectedEdges(n.id).forEach(eid => edgesToShow.add(eid));
          }
        });

        // Ensure nodes of shown edges also visible
        Array.from(edgesToShow).forEach(eid => {
          const e = network.body.data.edges.get(eid);
          if (e) { nodesToShow.add(e.from); nodesToShow.add(e.to); }
        });
      } else {
        network.body.data.edges.get().forEach(e => {
          const match = property === 'inferred'
            ? String(e.dashes === true) === value
            : (e[property] !== undefined && String(e[property]) === value);

          if (match) {
            edgesToShow.add(e.id);
            nodesToShow.add(e.from);
            nodesToShow.add(e.to);
          }
        });
      }

      network.body.data.nodes.update(network.body.data.nodes.get().map(n => ({ id:n.id, hidden: !nodesToShow.has(n.id) })));
      network.body.data.edges.update(network.body.data.edges.get().map(e => ({ id:e.id, hidden: !edgesToShow.has(e.id) })));
      network.fit();
    } catch (err) {
      console.error(err);
      alert('Error applying filter (see console).');
    }
  }

  function resetSelection() {
    try {
      network.unselectAll();
      network.body.data.nodes.update(network.body.data.nodes.get().map(n => ({ id:n.id, hidden:false })));
      network.body.data.edges.update(network.body.data.edges.get().map(e => ({ id:e.id, hidden:false })));
      network.fit();
    } catch {}
  }

  function selectNode(nodeId) {
    if (!nodeId) { resetSelection(); return; }
    try {
      network.selectNodes([nodeId]);
      network.focus(nodeId, { scale: 1.5, animation:{ duration: 700, easingFunction:"easeInOutQuad" } });
    } catch {}
  }

  function updateGraphStats() {
    try {
      const nodes = network.body.data.nodes.get();
      const edges = network.body.data.edges.get();
      document.getElementById('stat-nodes').textContent = nodes.length;
      document.getElementById('stat-edges').textContent = edges.length;

      let inferred = 0;
      edges.forEach(e => { if (e.dashes === true || (Array.isArray(e.dashes) && e.dashes.length > 0)) inferred++; });
      document.getElementById('stat-inferred').textContent = inferred;
      document.getElementById('stat-extracted').textContent = edges.length - inferred;

      const communities = new Set(nodes.map(n => n.color).filter(Boolean));
      document.getElementById('stat-communities').textContent = communities.size;
    } catch {}
  }

;

  window.addEventListener('resize', () => { if (window.network) network.fit(); });
</script>
